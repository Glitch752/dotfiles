import os
from typing import Optional

from .logging import PrettyLogger
from .config import DotsConfig, ResolvedConfig
from pathlib import Path
from jinja2 import Environment, FileSystemLoader
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

import tempfile
import shutil
import pwd

ACONFMGR_IGNORE_PATH = Path(__file__).parent.parent.parent.parent / "aconfmgr" / "5-dotmgr-autogenerated-ignores.sh"

# Write content to a temporary file, then move it atomically to the destination.
def write_atomic_as_user(username: Optional[str], filepath: Path, content: str):
    dirpath = filepath.parent
    with tempfile.NamedTemporaryFile('w', dir=dirpath, delete=False) as tf:
        tf.write(content)
        tempname = tf.name

    # Change ownership if username is specified
    if username:
        pw = pwd.getpwnam(username)
        os.chown(tempname, pw.pw_uid, pw.pw_gid)

    os.replace(tempname, filepath)
    # Set appropriate permissions
    os.chmod(filepath, 0o644)

def copy_atomic_as_user(username: Optional[str], src: Path, dst: Path):
    dst.parent.mkdir(parents=True, exist_ok=True)
    with tempfile.NamedTemporaryFile('wb', dir=dst.parent, delete=False) as tf:
        with open(src, 'rb') as sf:
            shutil.copyfileobj(sf, tf)
        tempname = tf.name

    if username:
        pw = pwd.getpwnam(username)
        os.chown(tempname, pw.pw_uid, pw.pw_gid)

    os.replace(tempname, dst)
    # Set appropriate permissions
    os.chmod(dst, 0o644)

class DotfileManager:
    dots_dir: Path
    config: ResolvedConfig
    profile: str
    log: PrettyLogger
    
    def __init__(self, dots_dir: Path, profile: str):
        self.dots_dir = dots_dir
        self.log = PrettyLogger()
        
        if not self.dots_dir.exists():
            # If the dots directory does not exist, create it with the default content in ./default_dots
            self.create_default_dots()
        
        self.profile = profile
        try:
            self.reload_config()
        except RuntimeError as e:
            self.log.error(f"Failed to load configuration: {e}")
            os._exit(1)
        
        self.env = Environment(
            loader=FileSystemLoader(self.dots_dir),
            autoescape=True,
            
            block_start_string="{%",
            block_end_string="%}",
            variable_start_string="{{",
            variable_end_string="}}",
            comment_start_string="{#",
            comment_end_string="#}",
            keep_trailing_newline=True
        )
        
    def reload_config(self):
        try:
            self.config = DotsConfig(self.dots_dir / "config.toml").resolve_profile(self.profile)
        except Exception as e:
            self.log.error(f"Error loading configuration: {e}")
            raise RuntimeError(f"Failed to load configuration for profile '{self.profile}'") from e
    
    def create_default_dots(self):
        default_dots = Path(__file__).parent / "default_dots"
        if default_dots.exists():
            self.log.info(f"Creating default dots directory at {self.dots_dir}")
            self.dots_dir.mkdir(parents=True, exist_ok=True)
            # recursively copy the contents of default_dots to dots_dir
            self.copy_folder(default_dots, self.dots_dir)
            
    def copy_folder(self, src, dst):
        if not dst.exists():
            dst.mkdir(parents=True, exist_ok=True)
        for item in src.iterdir():
            if item.is_dir():
                self.copy_folder(item, dst / item.name)
            else:
                (dst / item.name).write_bytes(item.read_bytes())

    def render_templates(self):
        # HACK: This should be replaced by a more general solution
        aconfmgr_ignores = "# Generated by dotmgr\n"
        
        with self.log.info("Rendering templates"):
            for to_render in self.config.render:
                output_path = to_render.destination
                
                if to_render.copy:
                    source = self.dots_dir / to_render.source
                    if not source.exists():
                        self.log.error(f"Source file does not exist: {source}")
                        continue
                    copy_atomic_as_user(to_render.user, source, output_path)
                    self.log.info(f"Copied: {output_path}")
                else:
                    try:
                        rendered = self.env.get_template(to_render.source.as_posix()).render(self.config.variables)
                    except Exception as e:
                        self.log.error(f"Error rendering template {to_render.source}: {e}")
                        continue

                    # Write to temp file and rename atomically
                    write_atomic_as_user(to_render.user, output_path, rendered)
                    self.log.info(f"Rendered and updated: {output_path}")
            
                aconfmgr_ignores += f"IgnorePath '{output_path.as_posix()}'\n"
        
        # Write the aconfmgr ignores file
        with self.log.info(f"Writing aconfmgr ignores to {ACONFMGR_IGNORE_PATH}"):
            with open(ACONFMGR_IGNORE_PATH, "w") as f:
                f.write(aconfmgr_ignores)
            self.log.info("Aconfmgr ignores updated.")

    def watch(self):
        class ReloadHandler(FileSystemEventHandler):
            manager: "DotfileManager"
            
            def __init__(self, manager):
                self.manager = manager

            def on_modified(self, event):
                # Avoid double handling of events by avoiding directory reloads
                if event.is_directory:
                    return
                
                with self.manager.log.info("Change detected. Re-rendering templates..."):
                    try:
                        self.manager.reload_config()
                    except RuntimeError as e:
                        self.manager.log.error(f"Failed to reload configuration: {e}")
                        return
                    self.manager.render_templates()

        observer = Observer()
        observer.schedule(ReloadHandler(self), path=str(self.dots_dir), recursive=True)
        observer.start()
        
        self.log.info("Watching for changes. Press Ctrl+C to exit.")
        try:
            while True:
                pass
        except KeyboardInterrupt:
            observer.stop()
        observer.join()