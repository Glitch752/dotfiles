import os
import subprocess
from typing import Optional

from .logging import PrettyLogger
from .config import DotsConfig, ResolvedConfig
from pathlib import Path
from jinja2 import Environment, FileSystemLoader
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

ACONFMGR_IGNORE_PATH = Path(__file__).parent.parent.parent.parent / "aconfmgr" / "5-dotmgr-autogenerated-ignores.sh"

def write_atomic_as_user(username: Optional[str], filepath: Path, content: str):
    # If the user is ourself, we can write directly
    if username is None or username == os.getenv("USER"):
        with open(filepath, "w") as f:
            f.write(content)
        return
    # Otherwise, we need to run a subprocess as that user
    script = f"""
import os
from pathlib import Path

output_path = Path("{filepath}")
tmp_path = output_path.with_suffix(output_path.suffix + ".tmp")

with open(tmp_path, "w") as f:
  f.write({repr(content)})

os.replace(tmp_path, output_path)
"""
    subprocess.run(
        ['sudo', '-u', username, 'python3', '-c', script],
        check=True
    )

class DotfileManager:
    dots_dir: Path
    config: ResolvedConfig
    profile: str
    log: PrettyLogger
    
    def __init__(self, dots_dir: Path, profile: str):
        self.dots_dir = dots_dir
        self.log = PrettyLogger()
        
        if not self.dots_dir.exists():
            # If the dots directory does not exist, create it with the default content in ./default_dots
            self.create_default_dots()
        
        self.profile = profile
        try:
            self.reload_config()
        except RuntimeError as e:
            self.log.error(f"Failed to load configuration: {e}")
            os._exit(1)
        
        self.env = Environment(
            loader=FileSystemLoader(self.dots_dir),
            autoescape=True,
            
            block_start_string="{%",
            block_end_string="%}",
            variable_start_string="{{",
            variable_end_string="}}",
            comment_start_string="{#",
            comment_end_string="#}",
            keep_trailing_newline=True
        )
        
    def reload_config(self):
        try:
            self.config = DotsConfig(self.dots_dir / "config.toml").resolve_profile(self.profile)
        except Exception as e:
            self.log.error(f"Error loading configuration: {e}")
            raise RuntimeError(f"Failed to load configuration for profile '{self.profile}'") from e
    
    def create_default_dots(self):
        default_dots = Path(__file__).parent / "default_dots"
        if default_dots.exists():
            self.log.info(f"Creating default dots directory at {self.dots_dir}")
            self.dots_dir.mkdir(parents=True, exist_ok=True)
            # recursively copy the contents of default_dots to dots_dir
            self.copy_folder(default_dots, self.dots_dir)
            
    def copy_folder(self, src, dst):
        if not dst.exists():
            dst.mkdir(parents=True, exist_ok=True)
        for item in src.iterdir():
            if item.is_dir():
                self.copy_folder(item, dst / item.name)
            else:
                (dst / item.name).write_bytes(item.read_bytes())

    def render_templates(self):
        # HACK: This should be replaced by a more general solution
        aconfmgr_ignores = "# Generated by dotmgr\n"
        
        with self.log.info("Rendering templates"):
            for to_render in self.config.render:
                output_path = to_render.destination
                
                try:
                    rendered = self.env.get_template(to_render.source.as_posix()).render(self.config.variables)
                except Exception as e:
                    self.log.error(f"Error rendering template {to_render.source}: {e}")
                    continue

                # Write to temp file and rename atomically
                write_atomic_as_user(to_render.user, output_path, rendered)
                self.log.info(f"Rendered and updated: {output_path}")
            
                aconfmgr_ignores += f"IgnorePath '{output_path.as_posix()}'\n"
        
        # Write the aconfmgr ignores file
        with self.log.info(f"Writing aconfmgr ignores to {ACONFMGR_IGNORE_PATH}"):
            with open(ACONFMGR_IGNORE_PATH, "w") as f:
                f.write(aconfmgr_ignores)
            self.log.info("Aconfmgr ignores updated.")

    def watch(self):
        class ReloadHandler(FileSystemEventHandler):
            manager: "DotfileManager"
            
            def __init__(self, manager):
                self.manager = manager

            def on_modified(self, event):
                # Avoid double handling of events by avoiding directory reloads
                if event.is_directory:
                    return
                
                with self.manager.log.info("Change detected. Re-rendering templates..."):
                    try:
                        self.manager.reload_config()
                    except RuntimeError as e:
                        self.manager.log.error(f"Failed to reload configuration: {e}")
                        return
                    self.manager.render_templates()

        observer = Observer()
        observer.schedule(ReloadHandler(self), path=str(self.dots_dir), recursive=True)
        observer.start()
        
        self.log.info("Watching for changes. Press Ctrl+C to exit.")
        try:
            while True:
                pass
        except KeyboardInterrupt:
            observer.stop()
        observer.join()