import os
from typing import Optional

from .logging import PrettyLogger
from .config import DotsConfig, ResolvedConfig
from pathlib import Path
from jinja2 import Environment, FileSystemLoader
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

import tempfile
import shutil
import pwd

ACONFMGR_IGNORE_PATH = Path(__file__).parent.parent.parent.parent / "aconfmgr" / "5-dotmgr-autogenerated-ignores.sh"

def expand_user_to(user: str, path: str) -> str:
    import pwd
    if path.startswith("~"):
        path = f"{pwd.getpwnam(user).pw_dir}{path[1:]}"
    return path

# Write content to a temporary file, then move it atomically to the destination.
def write_atomic(filepath: Path, content: str):
    dirpath = filepath.parent
    with tempfile.NamedTemporaryFile('w', dir=dirpath, delete=False) as tf:
        tf.write(content)
        tempname = tf.name

    os.replace(tempname, filepath)

def walk_files(dir: Path) -> list[str]:
    res = []
    for (dirpath, _, filenames) in os.walk(dir):
        for filename in filenames:
            res.append(os.path.join(dirpath, filename))
    return res

def copy_atomic(src: Path, dst: Path):
    dst.parent.mkdir(parents=True, exist_ok=True)
    
    # If the source is a directory, copy each file individually (and don't care about being atomic because whatever)
    if src.is_dir():
        shutil.copytree(src, dst, dirs_exist_ok=True)
        return
    
    with tempfile.NamedTemporaryFile('wb', dir=dst.parent, delete=False) as tf:
        with open(src, 'rb') as sf:
            shutil.copyfileobj(sf, tf)
        tempname = tf.name

    os.replace(tempname, dst)

class DotfileManager:
    dots_dir: Path
    config: ResolvedConfig
    profile: str
    log: PrettyLogger
    
    def __init__(self, dots_dir: Path, profile: str):
        self.dots_dir = dots_dir
        self.log = PrettyLogger()
        
        if not self.dots_dir.exists():
            # If the dots directory does not exist, create it with the default content in ./default_dots
            self.create_default_dots()
        
        self.profile = profile
        try:
            self.reload_config()
        except RuntimeError as e:
            self.log.error(f"Failed to load configuration: {e}")
            os._exit(1)
        
        self.env = Environment(
            loader=FileSystemLoader(self.dots_dir),
            autoescape=True,
            
            block_start_string="{%",
            block_end_string="%}",
            variable_start_string="{{",
            variable_end_string="}}",
            comment_start_string="{#",
            comment_end_string="#}",
            keep_trailing_newline=True
        )
        
    def reload_config(self):
        try:
            self.config = DotsConfig(self.dots_dir / "config.toml").resolve_profile(self.profile)
        except Exception as e:
            self.log.error(f"Error loading configuration: {e}")
            raise RuntimeError(f"Failed to load configuration for profile '{self.profile}'") from e
    
    def create_default_dots(self):
        default_dots = Path(__file__).parent / "default_dots"
        if default_dots.exists():
            self.log.info(f"Creating default dots directory at {self.dots_dir}")
            self.dots_dir.mkdir(parents=True, exist_ok=True)
            # recursively copy the contents of default_dots to dots_dir
            self.copy_folder(default_dots, self.dots_dir)
            
    def copy_folder(self, src, dst):
        if not dst.exists():
            dst.mkdir(parents=True, exist_ok=True)
        for item in src.iterdir():
            if item.is_dir():
                self.copy_folder(item, dst / item.name)
            else:
                (dst / item.name).write_bytes(item.read_bytes())

    def render_templates(self):
        # HACK: This should be replaced by a more general solution
        aconfmgr_ignores = "# Generated by dotmgr\n"
        
        user = os.getlogin()
                
        with self.log.info("Rendering templates"):
            for to_render in self.config.render:
                username = user if to_render.as_user == None else to_render.as_user
                
                output_path = Path(expand_user_to(username, str(to_render.destination)))
                if not output_path.is_absolute():
                    raise ValueError(f"Render destination path '{output_path}' must be absolute.")
                
                self.log.info(f"Rendering {to_render.source}")
                
                pw = pwd.getpwnam(username)
                os.seteuid(os.getuid()) # Allow setegid
                os.setegid(pw.pw_gid)
                os.seteuid(pw.pw_uid)
                    
                if to_render.action == "copy":
                    source = self.dots_dir / to_render.source
                    if not source.exists():
                        self.log.error(f"Source file does not exist: {source}")
                        continue
                    copy_atomic(source, output_path)
                    self.log.info(f"Copied: {output_path}")
                elif to_render.action == "link":
                    source = self.dots_dir / to_render.source
                    if not source.exists():
                        self.log.error(f"Source file does not exist: {source}")
                        continue
                    try:
                        if output_path.exists():
                            output_path.unlink()
                        os.symlink(source, output_path)
                        self.log.info(f"Linked: {output_path} -> {source}")
                    except OSError:
                        self.log.error(f"Link already exists: {output_path}. Skipping.")
                        continue
                else:
                    try:
                        rendered = self.env.get_template(to_render.source.as_posix()).render(self.config.variables)
                    except Exception as e:
                        self.log.error(f"Error rendering template {to_render.source}: {e}")
                        continue

                    # Write to temp file and rename atomically
                    write_atomic(output_path, rendered)
                    self.log.info(f"Rendered and updated: {output_path}")
                
                if to_render.permissions:
                    try:
                        os.chmod(output_path, int(to_render.permissions, 8))
                        self.log.info(f"Set permissions for {output_path} to {to_render.permissions}")
                    except Exception as e:
                        self.log.error(f"Error setting permissions for {output_path}: {e}")
            
                aconfmgr_ignores += f"IgnorePath '{output_path.as_posix()}'\n"
        
        # Write the aconfmgr ignores file
        with self.log.info(f"Writing aconfmgr ignores to {ACONFMGR_IGNORE_PATH}"):
            with open(ACONFMGR_IGNORE_PATH, "w") as f:
                f.write(aconfmgr_ignores)
            self.log.info("Aconfmgr ignores updated.")

    def watch(self):
        class ReloadHandler(FileSystemEventHandler):
            manager: "DotfileManager"
            
            def __init__(self, manager):
                self.manager = manager

            def on_modified(self, event):
                # Avoid double handling of events by avoiding directory reloads
                if event.is_directory:
                    return
                
                with self.manager.log.info("Change detected. Re-rendering templates..."):
                    try:
                        self.manager.reload_config()
                    except RuntimeError as e:
                        self.manager.log.error(f"Failed to reload configuration: {e}")
                        return
                    self.manager.render_templates()

        observer = Observer()
        observer.schedule(ReloadHandler(self), path=str(self.dots_dir), recursive=True)
        observer.start()
        
        self.log.info("Watching for changes. Press Ctrl+C to exit.")
        try:
            while True:
                pass
        except KeyboardInterrupt:
            observer.stop()
        observer.join()